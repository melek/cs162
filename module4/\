#include "string.h"
#include <iostream>

// Default constructor
string::string() {
     size           = 0;
     capacity       = 0;
     cstring          = nullptr;
}

// Copy constructor
string::string(const string & right) {
    size           = right.size;
    capacity       = right.capacity;
    cstring          = new char[capacity];
    for(auto i = 0; i < capacity; i++) 
         cstring[i]   = right[i];
}

// Parameterized copy constructor
string::string(const char * right) {
    size            = strlen(right);
    capacity        = size + 1;
    cstring           = new char[capacity];
    for(auto i = 0; i < capacity; i++)
        cstring[i]    = right[i];
}

// Move constructor 
string::string(string && right) {
    if(this != &right) {
        size        = right.size;
        capacity    = right.capacity;
        cstring       = right.cstring;
        right.size     = 0;
        right.capacity = 0;
        right.cstring    = nullptr;
    }
}

// Destructor
string::~string() {
    size     = 0;
    capacity = 0;
    if(cstring != nullptr) delete [] cstring;
}

// Copy assignment operator
string & string::operator = (const string & right) {
    if (this != &right) {
        size      = right.size;
        capacity  = right.capacity;
        if(cstring != nullptr) delete [] cstring;
        cstring = new char[capacity];
        for(auto i = 0; i < capacity; i++)
            cstring[i] = right[i];
    }
    return *this;
}

// Parameterized copy assignment operator
string & string::operator = (const char * right) {
    size        = strlen(right);
    capacity    = size + 1;
    if(cstring != nullptr) delete [] cstring;
    cstring       = new char[capacity];
    for(auto i = 0; i < capacity; i++)
        cstring[i] = right[i];
    return *this;
}

// Move assignment operator
string & string::operator = (string && right) {     
    if (this != &right) {
        size      = right.size;
        capacity  = right.capacity;
        if(cstring != nullptr) delete [] cstring;
        cstring           = right.cstring;
        right.size      = 0;
        right.capacity  = 0;
        right.cstring     = nullptr;
    }
    return *this;
}

// Subscript operators
char & string::operator [] (int position) {
    return at(position);
}

char & string::at(int position) {
    if (position <= 0)    return cstring[0];
    if (position >= size) return cstring[size];
    return cstring[position];
}

const char & string::operator [] (int position) const {
    return const_cast<char&>(at(position));
}

// Size & Capacity checkers
bool string::is_empty() {
    return size == 0;
}

bool string::is_full() {
    return (size + 1) == capacity;
}

// Getters
int string::get_size() const {
    return size;
}

int string::length() const {
    return size;
}

int string::get_capacity() const {
    return capacity;
}

char * string::c_str() const {
    return cstring;
}

// Setters
void string::set(const string & right) {
    *this = right;
}

void string::set(const char * right) {
    *this = right;
}

// Helper functions
const int strlen(const char * cstring) {
    int i = 0;
    for(i = 0; cstring[i] != '\0'; i++);
    return i;
}

// Core relational operators
bool operator == (const string & left, const string & right)
{   return left.length() == right.length(); }

bool operator >  (const string & left, const string & right)
{   return left.length() > right.length();  }

// Derived relational operators
bool operator != (const string & left, const string & right) { return !(left == right); }
bool operator <  (const string & left, const string & right) { return   left != right && !(left > right); }
bool operator >= (const string & left, const string & right) { return !(left <  right); }
bool operator <= (const string & left, const string & right) { return !(left >  right); }

// Stream operators
std::ostream & operator << (std::ostream & out, const string & right)
{
    out << right.c_str(); 
    return out;
}

std::istream & operator >> (std::istream & in, string & right)
{
    int size = 0;
    int capacity = 20;
    char * input = new char[20];
    char c;
    while(in.good() == true && in.peek() != '\n' && in.peek() > ' ') {
        if(size >= capacity) {
            capacity += chunk;
            char * temp = new char[capacity];
            for(int i = 0; i < size; i++) temp[i] = input[i];
            delete [] input;
            input = temp;
        }
        in >> c;
        if(in.good()) input[size++] = c;
    }
    right = input;
    delete [] input;   
    return in;
}

